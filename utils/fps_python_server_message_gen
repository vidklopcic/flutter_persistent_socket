#!/usr/bin/python3

import argparse
import sys
import re
import os


class MessageGen():
    def __init__(self, path, spec, proto):
        self.path = path
        self.proto = proto.strip()
        self.spec = spec.strip()
        self.spec_items = [i.strip() for i in self.spec.split('\n') if i.strip()]

    def get_type(self):
        return re.search('type.+=.+\'(.+)\'', self.spec).group(1)

    def get_import(self):
        return 'from proto.%s import *' % self.path.split('.proto')[0].split('/')[-1]

    def get_server_prefix(self):
        if 'client' in re.search('origin.+=(.+)', self.spec).group(1):
            return 'Rx'
        else:
            return 'Tx'

    def get_server_message_classname(self):
        return self.get_server_prefix() + self.proto

    def is_auth_required(self):
        auth = re.search('auth\s*=\s*(.+)\s*', self.spec)
        if auth:
            return auth.group(1).capitalize()
        else:
            return 'True'

    def get_server_message(self) -> str:
        message = '''

class {prefix}{proto}({prefix}Message):
    type = '{type}'
    proto = {proto}
    auth_required = {auth}
'''.format(prefix=self.get_server_prefix(), proto=self.proto, type=self.get_type(), auth=self.is_auth_required())

        return message

    def __str__(self):
        return self.proto + ' (' + self.path + ')'


args = argparse.ArgumentParser(description='Generate message objects from proto and docstring specs.')
args.add_argument(type=str, nargs='+', dest='protos', help='list of proto files')
params = args.parse_args(sys.argv[1:])

generators = []
for f in params.protos:
    proto_content = open(f, 'r', encoding='utf-8').read()
    generators += [MessageGen(f, i[0], i[1]) for i in
                   re.findall('/\*(.+?)\*/\nmessage(.+?){', proto_content, flags=re.S)]

imports = {'from abc import ABC', 'import dataclasses'}
imports.update(set([i.get_import() for i in generators]))

with open('proto/messages.py', 'w', encoding='utf-8') as f:
    f.write('\n'.join(imports))
    f.write('''


class RxMessageData:
    def __init__(self, json_data: dict):
        self.headers = json_data.get('headers')
        self.body = json_data.get('body')
        self.authHeader = self.headers.get('authHeader')
        self.type = self.headers.get('messageType')


class RxMessage(ABC):
    proto = None
    type = None
    auth_required = True

    def __init__(self, data: RxMessageData):
        self.data = data
        self.set_data(data)

    def set_data(self, data: RxMessageData):
        self.set_by_number(data.body)

    @staticmethod
    def get_field_map(proto) -> Dict:
        fields = {}
        for field in dataclasses.fields(proto):
            meta = FieldMetadata.get(field)
            fields[str(meta.number)] = (betterproto.Casing.SNAKE(field.name), meta, field)
        return fields

    @staticmethod
    def num_to_name_dict(proto, data: dict):
        fields = RxMessage.get_field_map(proto)
        name_dict = {}
        for num in data:
            name, meta, field = fields.get(num)
            if not meta:
                continue
            obj = data[num]
            if meta.proto_type == 'message':
                obj = getattr(proto, name).from_dict(RxMessage.num_to_name_dict(getattr(proto, name), obj))
            name_dict[name] = obj
        return name_dict

    def set_by_number(self, data: dict):
        name_dict = RxMessage.num_to_name_dict(self.proto(), data)
        self.proto = self.proto(**name_dict)


class TxMessage(ABC):
    proto: betterproto.Message = None
    type: str = None

    def __init__(self, proto=None):
        self.fields = {}
        if proto is not None:
            assert type(proto) is self.proto
            self.proto = proto
        else:
            self.proto = self.proto()

    def get_message(self) -> dict:
        return {
            'headers': {
                'messageType': self.type,
            },
            'body': self.get_number_dict()
        }

    @staticmethod
    def get_field_map(proto) -> Dict:
        fields = {}
        for field in dataclasses.fields(proto):
            meta = field.metadata['betterproto']
            fields[betterproto.Casing.CAMEL(field.name)] = meta
        return fields

    @staticmethod
    def to_number_dict(proto):
        name_dict = proto.to_dict()
        fields = TxMessage.get_field_map(proto)
        num_dict = {}
        for name in name_dict:
            obj = name_dict[name]
            if fields[name].proto_type == 'message':
                obj = TxMessage.to_number_dict(getattr(proto, name))
            num_dict[str(fields[name].number)] = obj
        return num_dict

    def get_number_dict(self) -> Dict:
        return TxMessage.to_number_dict(self.proto)
''')

    classnames = []
    for generator in generators:
        try:
            f.write(generator.get_server_message())
            classnames.append(generator.get_server_message_classname())
        except Exception as e:
            print('Syntax error:', generator)
            print(e)
    f.write('''

class Messages:
    %s
''' % '\n    '.join(['%s = %s' % (i.lower()[0] + i[1:], i) for i in classnames]))
