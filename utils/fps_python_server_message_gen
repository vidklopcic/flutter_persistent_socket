#!/usr/bin/python3

import argparse
import sys
import re
import os


class MessageGen():
    def __init__(self, path, spec, proto):
        self.path = path
        self.proto = proto.strip()
        self.spec = spec.strip()
        self.spec_items = [i.strip() for i in self.spec.split('\n') if i.strip()]

    def get_type(self):
        return re.search('type.+=.+\'(.+)\'', self.spec).group(1)

    def get_import(self):
        return 'from proto.%s import *' % self.path.split('.proto')[0].split('/')[-1]

    def get_server_prefix(self):
        if 'client' in re.search('origin.+=(.+)', self.spec).group(1):
            return 'Rx'
        else:
            return 'Tx'

    def get_server_message_classname(self):
        return self.get_server_prefix() + self.proto

    def is_auth_required(self):
        auth = re.search('auth\s*=\s*(.+)\s*', self.spec)
        if auth:
            return auth.group(1).capitalize()
        else:
            return 'True'

    def permissions(self):
        permissions = ('')

    def get_server_message(self) -> str:
        message = '''

class {prefix}{proto}({prefix}Message):
    type = '{type}'
    proto = {proto}
    auth_required = {auth}
    permissions = [{permissions}]
'''.format(prefix=self.get_server_prefix(), proto=self.proto, type=self.get_type(), auth=self.is_auth_required(), permissions=self.permissions())

        return message

    def __str__(self):
        return self.proto + ' (' + self.path + ')'


args = argparse.ArgumentParser(description='Generate message objects from proto and docstring specs.')
args.add_argument(type=str, nargs='+', dest='protos', help='list of proto files')
params = args.parse_args(sys.argv[1:])

generators = []
for f in params.protos:
    proto_content = open(f, 'r', encoding='utf-8').read()
    generators += [MessageGen(f, i[0], i[1]) for i in
                   re.findall('/\*(.+?)\*/\nmessage(.+?){', proto_content, flags=re.S)]

imports = {'from abc import ABC', 'import dataclasses', 'from betterproto import *'}
imports.update(set([i.get_import() for i in generators]))

with open('proto/messages.py', 'w', encoding='utf-8') as f:
    f.write('\n'.join(imports))
    f.write('''


class RxMessageData:
    def __init__(self, json_data: dict):
        self.headers = json_data.get('headers')
        self.body = json_data.get('body')
        self.authHeader = self.headers.get('authHeader')
        self.type = self.headers.get('messageType')


class RxMessage(ABC):
    proto = None
    type = None
    auth_required = True

    def __init__(self, data: RxMessageData):
        self.data = data
        self.set_data(data)

    def set_data(self, data: RxMessageData):
        self.proto = self.proto().from_dict(data.body)

class TxMessage(ABC):
    proto: betterproto.Message = None
    type: str = None

    def __init__(self, proto=None):
        self.fields = {}
        if proto is not None:
            assert type(proto) is self.proto
            self.proto = proto
        else:
            self.proto = self.proto()

    def get_message(self) -> dict:
        return {
            'headers': {
                'messageType': self.type,
            },
            'body': self.proto.to_dict()
        }

def to_dict_patch(
        self, casing: Casing = Casing.CAMEL, include_default_values: bool = False
) -> dict:
    """
    Returns a dict representation of this message instance which can be
    used to serialize to e.g. JSON. Defaults to camel casing for
    compatibility but can be set to other modes.

    `include_default_values` can be set to `True` to include default
    values of fields. E.g. an `int32` type field with `0` value will
    not be in returned dict if `include_default_values` is set to
    `False`.
    """
    output: Dict[str, Any] = {}
    for field in dataclasses.fields(self):
        meta = FieldMetadata.get(field)
        v = getattr(self, field.name)
        cased_name = str(meta.number)
        if meta.proto_type == "message":
            if isinstance(v, datetime):
                if v != DATETIME_ZERO or include_default_values:
                    output[cased_name] = _Timestamp.timestamp_to_json(v)
            elif isinstance(v, timedelta):
                if v != timedelta(0) or include_default_values:
                    output[cased_name] = _Duration.delta_to_json(v)
            elif meta.wraps:
                if v is not None or include_default_values:
                    output[cased_name] = v
            elif isinstance(v, list):
                # Convert each item.
                v = [i.to_dict(casing, include_default_values) for i in v]
                if v or include_default_values:
                    output[cased_name] = v
            else:
                if v._serialized_on_wire or include_default_values:
                    output[cased_name] = v.to_dict(casing, include_default_values)
        elif meta.proto_type == "map":
            for k in v:
                if hasattr(v[k], "to_dict"):
                    v[k] = v[k].to_dict(casing, include_default_values)

            if v or include_default_values:
                output[cased_name] = [{'1': k, '2': v} for k, v in v.items()]
        elif v != self._get_field_default(field, meta) or include_default_values:
            if meta.proto_type in INT_64_TYPES:
                if isinstance(v, list):
                    output[cased_name] = [str(n) for n in v]
                else:
                    output[cased_name] = str(v)
            elif meta.proto_type == TYPE_BYTES:
                if isinstance(v, list):
                    output[cased_name] = [b64encode(b).decode("utf8") for b in v]
                else:
                    output[cased_name] = b64encode(v).decode("utf8")
            elif meta.proto_type == TYPE_ENUM:
                if isinstance(v, list):
                    output[cased_name] = [e for e in v]
                else:
                    output[cased_name] = v
            else:
                output[cased_name] = v
    return output


def from_dict_patch(self: T, value: dict) -> T:
    """
    Parse the key/value pairs in `value` into this message instance. This
    returns the instance itself and is therefore assignable and chainable.
    """
    self._serialized_on_wire = True
    fields_by_name = {str(FieldMetadata.get(f).number): f for f in dataclasses.fields(self)}
    for key in value:
        snake_cased = safe_snake_case(key)
        if snake_cased in fields_by_name:
            field = fields_by_name[snake_cased]
            meta = FieldMetadata.get(field)

            if value[key] is not None:
                if meta.proto_type == "message":
                    v = getattr(self, field.name)
                    if isinstance(v, list):
                        cls = self._betterproto.cls_by_field[field.name]
                        for i in range(len(value[key])):
                            v.append(cls().from_dict(value[key][i]))
                    elif isinstance(v, datetime):
                        v = datetime.fromisoformat(
                            value[key].replace("Z", "+00:00")
                        )
                        setattr(self, field.name, v)
                    elif isinstance(v, timedelta):
                        v = timedelta(seconds=float(value[key][:-1]))
                        setattr(self, field.name, v)
                    elif meta.wraps:
                        setattr(self, field.name, value[key])
                    else:
                        v.from_dict(value[key])
                elif meta.map_types and meta.map_types[1] == TYPE_MESSAGE:
                    v = getattr(self, field.name)
                    cls = self._betterproto.cls_by_field[field.name + ".value"]
                    for k in value[key]:
                        v[k] = cls().from_dict(value[key][k])
                else:
                    v = value[key]
                    if meta.proto_type in INT_64_TYPES:
                        if isinstance(value[key], list):
                            v = [int(n) for n in value[key]]
                        else:
                            v = int(value[key])
                    elif meta.proto_type == TYPE_BYTES:
                        if isinstance(value[key], list):
                            v = [b64decode(n) for n in value[key]]
                        else:
                            v = b64decode(value[key])
                    elif meta.proto_type == TYPE_ENUM:
                        # already in correct format as received
                        pass


                    if v is not None:
                        setattr(self, field.name, v)
    return self


def init_default_gen_patch(self):
    default_gen = {}

    for field in dataclasses.fields(self.cls):
        meta = FieldMetadata.get(field)
        if meta.proto_type == TYPE_MESSAGE:
            default_gen[field.name] = self.cls._get_field_default_gen(field, meta)
        else:
            default_gen[field.name] = lambda: None

    self.default_gen = default_gen


betterproto.Message.to_dict = to_dict_patch
betterproto.Message.from_dict = from_dict_patch
betterproto.ProtoClassMetadata.init_default_gen = init_default_gen_patch
''')

    for generator in generators:
        try:
            f.write(generator.get_server_message())
        except Exception as e:
            print('Syntax error:', generator)
            print(e)
